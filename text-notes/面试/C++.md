#### 1. 虚函数、虚继承、多态 [[1]](#[1])

多态类型是指声明或者继承了至少一个虚函数的类型，反之则为非多态类型。我们可以用基类型`A`的引用或者指针持有实际类型为派生类`B`的对象，这意味着，**在编译时无法通过其声明类型来确定其实际类型**，也就无法确定应该调用哪个具体的虚函数；在运行时可以通过虚表找到实际类型的虚函数地址，从而调用实际类型的虚函数。

##### 1.1 虚表的内存模型（非虚继承）

对于多态类型，其虚函数记录在虚表中，每个虚函数入口地址相对于虚表起始地址的偏移量在基类和派生类中均相同，这使得**虚函数相对于虚表起始地址(虚指针)的偏移量可以在编译时确定**。**虚指针始终位于对象的起始地址**。使用多态类型的引用或指针调用虚函数时，首先通过**虚指针和偏移量计算出虚函数的地址**，然后进行调用。如何得到虚函数地址，则是由虚表的内存模型描述。

###### 1.1.1 单继承时内存模型(不完整)

例如类型 A、B，下面左图为两个类型定义，右图为对象模型和虚表模型

<img src="../../../source/images/C++.assets/image-20220723225625514.png" alt="image-20220723225625514" style="zoom: 67%;" /><img src="../../../source/images/C++.assets/image-20220723225657114.png" alt="image-20220723225657114" style="zoom: 55%;" />

可以看出 B 重写了虚函数 f0，对应 B 虚表里 B::f0()。因此在运行时调用 f0，实际类型为 A 的对象调用了 A::f0()，形如
`(a_ra->vptr_A + offset0) --> A::f0()`；实际类型为 B 的对象，同样的虚表偏移量调用了 B::f0()，形如 `(a_rb->vptr_A + 0ffset0) --> B::f0()`。

对于派生类声明了基类没有的虚函数，则会附加在虚表最后。例如 B 中新增虚函数 f2()，则虚表如下左图：

<img src="../../../source/images/C++.assets/image-20220723230727351.png" alt="image-20220723230727351" style="zoom: 55%;" /><img src="../../../source/images/C++.assets/image-20220723230943607.png" alt="image-20220723230943607" style="zoom:55%;" />

对于多态类型还需要提供运行时类型信息支持(RTTI)，g++ 编译器会放在虚表首位置，如上右图所示。

上述内存模型可以处理单链继承情况，虚函数可以按照继承顺序，依次排列在同一张虚表之中，因此只需要一个虚指针即可。并且**单链继承的数据在内存中是线性排布的**，这意味着实际类型与它所有的基类型都有着相同的起始地址。例如，A 派生 B、B 派生 C，它们的定义如下面左图、内存模型如右图所示：

<img src="../../../source/images/C++.assets/image-20220723232005311.png" alt="image-20220723232005311" style="zoom: 67%;" /><img src="../../../source/images/C++.assets/image-20220723232026691.png" alt="image-20220723232026691" style="zoom:67%;" />

如上图所示，如果类型 A、B 持有实际类型 C 的对象，它的起始地址仍然指向 C。**这意味着单链继承的情况下，动态向下或向上转换时，不需要对`this`指针的地址做出任何修改**，只需要对其重新“解释”。

###### 1.1.2 多重继承时内存模型

假设类型`C`同时继承了两个独立的基类`A`和`B`，定义如下左图、内存模型如右图所示：

<img src="../../../source/images/C++.assets/image-20220723233024645.png" alt="image-20220723233024645" style="zoom:60%;" /><img src="../../../source/images/C++.assets/image-20220723233043961.png" alt="image-20220723233043961" style="zoom:67%;" />

C 的两个基类 A、B 完全独立，它们的虚函数没有顺序关系，并且它们的成员变量也是无关的，因此同时需要有两个虚指针分别对它们虚函数进行索引，即上右图中的 `vptr_A`、`vptr_B`。需要多继承下对派生类虚函数的存放、以及虚表新增实体：

- 多继承时，派生类选择第一个基类作为主基类，按照单继承时的原则，将**派生类的虚函数并入主基类虚表中**。例如上右图中，C 选择 A 作为主基类，在 A 的虚表中覆盖 f0，并且追加 f1（虽然 f1 是从 B 中继承来的，相对于主基类是新增的）。

- **多继承下的派生类与基类的起始地址并不完全相同**
  由上左图可知，当 C 向上转换为 B 时，由于 A、B 起始地址不同，this 指针需要进行修改。虚表中新增实体 `offset_to_top` 则是用于描述向上转换时 this 指针需要施加的偏移量。注意：无论单继承或者多继承，`offset_to_top` **存在于每一个动态类型的虚表中**，只是单继承情况下始终为 0。

- 新增实体 `thunk` 用于定位到派生类继承来的虚函数。假设类型 B 持有实际类 C 的对象，C 的虚函数 f1 并入主基类虚表中，根据 f1 的偏移量和 B 虚指针找到 Thunk C::f1。B 的起始地址为 C+16，Thunk 的作用则是先调整 this 指针到 C 的起始地址，定位到实际类型 C 的 f1 虚函数地址。

非虚继承情况下，虚表中信息都是在编译时确定的，不需要运行时信息，因此在知道目标转换类型的情况下，可以使用 static_cast。

##### 1.2 虚继承的内存模型

上述的模型中，基类在派生类对象中的偏移量总是确定的，因此动态向下转换不需要运行时信息。而虚继承破坏了这一条件，虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得**虚基类在子类的偏移量在运行时才可以确定**。因此，**虚基类向下转换是不合法的，语法错误**。

为了避免菱形继承中重复包含成员，使用虚继承，菱形虚继承如下

<img src="../../../source/images/C++.assets/image-20220724004320501.png" alt="image-20220724004320501" style="zoom: 67%;" /><img src="../../../source/images/C++.assets/image-20220724004344148.png" alt="image-20220724004344148" style="zoom:67%;" /><img src="../../../source/images/C++.assets/image-20220724004404723.png" alt="image-20220724004404723" style="zoom:67%;" />

如上图所示，为了避免重复包含`A`中的成员，类型`B`和`C`分别虚继承`A`。类型`D`继承了`B`和`C`。因此`D`中的`B`、`C`的偏移量可以在编译时确定，而`A`的偏移量在运行时确定。

A 的内存模型与前述部分没有什么区别，如下图所示：

<img src="../../../source/images/C++.assets/image-20220724103213042.png" alt="image-20220724103213042" style="zoom: 67%;" />

而 B、C 的内存模型由于虚继承有变动，如下左图中的 B 的内存模型：

<img src="../../../source/images/C++.assets/image-20220724111113326.png" alt="image-20220724111113326" style="zoom:55%;" /><img src="../../../source/images/C++.assets/image-20220724111148705.png" alt="image-20220724111148705" style="zoom:53%;" />

虚继承在派生类中的虚表中新增 `vbase_offset`，用于定位虚基类在派生类中的位置。上右图是 D 的内存模型，可以看到 D 与 B 的起始地址相同，如果 B 类型持有实际类型 D 对象，这时虚基类在 B 中的偏移量为 32；而虚基类在实际类型为 B 的对象中的偏移量为 16。所以**需要确定运行时类型才能知道虚基类的偏移量**。

因此虚继承条件下，进行向下类型转换需要运行时信息，而 static_cast 仅根据目标转换类型的虚表信息进行对 this 指针调整，但目标转换类型不一定是运行时类型。

##### 1.3 虚表的创建与虚指针的初始化

vtable 不是C++的概念，因此是否使用，何时创建跟实现有关。通常 vtable 是在编译时创建的，当在运行时创建多态对象时会将 vptr 指向对应的 vtable。

在所有基类构造函数之后，但又在自身构造函数或初始化列表之前。vptr(虚指针) 初始化是在初始化列表之前还是之后是跟编译器实现有关的，在 VC++6.0 编译器中是在初始化列表之后。因此构造函数中调用虚函数可能导致未知行为。

#### 2. 类型转换

##### 2.1 static_cast

仅根据源类型中的编译信息，对 this 指针调整。因此转换过程没有运行时信息。合法的隐式转换都可以使用 static_cast。在继承中的转换：

- 向上转换：
  - 如果转换路径是确定(唯一)的，则可以进行且安全；
  - 对于非虚继承的菱形继承转换路径不唯一，如 B、C 继承 A，D 同时继承 B、C，D 到 A 的向上转换路径不唯一。不合法，语法错误。可以人为选择一条唯一路径转换，例如 D 到 B 到 A；
  - 对于虚继承的菱形继承可以转换，因此已知源类型，目标虚基类型的偏移量是确定的
- 向下转换：
  - 对于虚继承，虚基类在派生类中的偏移量根据实际类型的不同而不同，因此需要运行时信息。虚基类向下转换是不合法的，语法错误
  - 对于非虚继承：向下转换的路径不唯一是不合法的，语法错误，例如 A 到 D 的转换。
  - 对于非虚继承且向下转换的路径是唯一的：转换是合法的，但其转换过程只是根据虚表中的 `offset_to_top` (编译阶段生成) 对 this 指针调整，无运行时信息。如果目标转换类型与持有的实际类型相同，则转换结果是安全的；否则转换结果是不安全的。
- 非 public 继承向上/向下转换都不合法，语法错误

##### 2.2 dynamic_cast

运行时转换，具有运行时信息，专门处理多态类型。

- 向上转换与 static_cast 相同
- 向下转换：总是合法的。由于具有运行时信息，当目标转换类型与持有的实际类型不同，指针转换结果为 nullptr，引用 throw std::bad_cast。因此可以根据转换结果安全使用。
- 非 public 继承向上/向下转换都不合法，语法错误

##### 2.3 const_cast

const_cast 用于类型转换改变表达式的cv修饰符（const， volatile）

##### 2.4 reinterpret_cast

字节码级别的转换，比较危险。唯一保证：转换原类型与目标类型大小相同时，转换回原类型会获得原理的值。

##### 2.5 C 类型的转换

(type)object，函数式的cast：type(object)

#### 3. 析构函数与构造函数

##### 3.1 析构函数

###### 3.1.1 抛出异常是危险的

析构函数从语法上是可以抛出异常的，但是这样做很危险。通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding）——因发生异常而逐步退出复合语句和函数定义的过程。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，C++将调用terminate函数立即终止程序的执行。

###### 3.1.2 虚析构函数

虚析构函数主要用于多态类，且可能通过基类的指针释放派生类对象的资源。析构过程是从子类析构函数到父类析构函数。如果有基类指针进行 delete 时，虚析构函数在虚表里是子类的析构函数，这保证了析构函数的调用顺序，从子类到父类。如果析构函数非 virtual 时，则会导致内存泄漏。

如果不会通过基类对象指针 delete 派生类对象就不需要声明析构函数为 virtual。

###### 3.1.3 析构函数私有化的作用

由其他类来负责该类的生命周期（比如友元的manager类）或需要阻止对象的析构

##### 3.2 拷贝构造函数

- 拷贝构造函数的参数为什么要传引用而不是传值？
  如果 pass-by-value，传递参数也需要调用拷贝构造函数，从而陷入无限循环

#### 4. 生命周期与作用域

##### 4.1 对于非成员变量

###### 4.1.1 作用域

**全局变量**：具有全局作用域。全局变量只需在一个源文件中定义，其他源文件需要用 extern 关键字再次声明就可以使用。如果同样的全局变量在多个文件重复定义，再链接时会报重复定义的链接错误。

**局部变量**：只有局部作用域，它是自动对象（auto），离开其作用域，变量被撤销，其所占用的内存也被收回。

**静态局部变量**：具有局部作用域，**但只被初始化一次**。自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

**静态全局变量**：具有全局作用域，但与全局变量不同的是，它只对定义它的文件可见，其他文件不可见。换句话说，即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量，在链接时不会认为重复定义。

###### 4.1.2 内存分配

全局变量、静态局部变量、静态全局变量都在静态存储区分配空间；而局部变量在栈里分配空间。

从以上分析可以看出：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生命周期；把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。

##### 4.2 类的 static 成员

类的 static 成员属于类，而不属于任何一个对象，也就是说类的 static 成员由其所有对象共享。

**static 成员变量**：存放在全局数据区，内存空间在初始化时分配，但不能在类中初始化，类外初始化方式：

```c++
静态数据成员类型 类名::静态数据成员名＝初值
```

**static 成员函数**：没有 this 指针，因此无法直接访问非静态成员；不能声明 virtual，毫无意义，static 函数可以通过类直接调用，不会有运行时多态。

#### 5. CV 修饰符

##### 5.1 const 与 constexpr

**const 变量**：const 声明一个对象是常量，保证它初始化之后不会修改，编译器可以基于此进行优化

**const 成员函数**：const 可以用于 non-static 成员函数，保证该成员函数不会修改类的非静态成员。可以看作成员的 this指针的类型是 const T*。

**mutable**：即使对象是常量，也允许修改该成员变量；mutable 成员变量可以在 const 成员函数中被修改

**constexpr**：声明对象或函数是常量表达式，即在编译期可以得到的常量值

**常量指针与指针常量**：

```c++
const char* cpch;	// 表示指针指向内容不能通过该指针改变
char* const pchc;	// 表示指针不能指向其他地址
```

##### 5.2 volatile

类型修饰符，用来修饰被不同线程访问和修改的变量（硬件IO地址，会被程序之外的不可知作用改变）。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。如下面代码：

```c++
int i = 10;
int a = i;
int b = i; 
```

由于编译器发现两次从 i 读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。如果在 a、b 赋值语句之间插入修改 i 的汇编代码：

```assembly
__asm {
	mov dword ptr [ebp-4], 20h	// 将 i 值修改为 32
}
```

编译器开启优化发现 a、b 的值都为 10；不开优化则 a 为 10，b 为 32。而如果对 i 使用 volatile 修饰，b 都为 32，正是期待的结果。

对于指针，volatile 与 const 同样有两种方式，修饰指向的内容、修改指针变量。

#### 6. inline [[5]](#[5])



#### 7. 指针与引用

- 引用必须初始化，而指针可以不初始化

- 引用不能为空，而指针可以为空。

- 引用不能更换目标，指针可以改变指向

- 指针占内存

- 返回值是引用类型，有什么用？链式表达式

#### 8. lambda 表达式

lambda 表达式是能够捕获变量的匿名函数对象，每个lambda表达式会让编译器生成一个闭包类，lambda表达式中的语句会变成闭包类成员函数中的指令。使用方式：

<img src="../../../source/images/C++.assets/image-20220725100244063.png" alt="image-20220725100244063" style="zoom:67%;" />

可以用在需要函数对象的地方，比如 STL 中的各种算法；定义时立即执行的函数（IIFE）。

编译器为 lambda 表达式生成的闭包类，其内部相当于定义了对应成员函数(**默认为 const**) `operator(params) const`。lambda 可以在周围作用域内捕获变量，在其定义的函数内部使用，共有两种捕获方式：

1. 值捕获
   与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝。同时对于值捕获的变量，编译器将在闭包类中定义对应的非静态成员变量，创建时将拷贝到该成员变量。
   由于默认情况下，闭包类的重载函数为 const，因此值捕获的变量(虽然形式相同，但在内部使用的是成员变量)无法在其内修改。如果想要修改(外部变量的副本，并非原始值)，需要声明 lambda 为 mutable，如下形式

   ```c++
   auto add_x = [x](int a) mutable { x *= 2; return a + x; };  // 复制捕捉x
   ```

2. 引用捕获
   与引用传参类似，引用捕获保存的是引用，可以在 lambda 内部修改外部变量的值。但注意 lambda 不要超出引用捕获的生命周期。对于默认为 const，引用捕获相当于是 const 指针，即无法修改指针指向的地址，但可以修改指向内容。

以下为两种捕获形式的写法：

- `[]`：默认不捕获任何变量；
- `[=]`：按值捕获所有变量；`[&]`：按引用捕获所有变量
- `[x]`：仅按值捕获 x 变量，其它变量不捕获；`[&x]`：仅按引用捕获 x，其它变量不捕获
- `[=,&x]`：默认按值捕获所有变量，但 x 是例外，按引用捕获；`[&,x]`：x 按值捕获，其余按引用捕获
- `[this]`：捕获当前对象的 this 指针，相当于按值捕获指针变量；`[*this]`：按值捕获当前对象

#### 9. STL

标准模板库(Standard Template Library)，是C++的标准库之一，一套基于模板的容器类库以及相关算法。

##### 9.1 各种容器的底层机制

###### 9.1.1 vector

可变大小的动态数组，使用连续内存，支持随机存取；在尾部之外的位置插入/删除元素，会导致其后所有元素的移动，如果引起内存重新分配，则会导致所有元素拷贝；当空间不够装下新来数据时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间；当释放或者删除（clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。如果对vector的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效了。

- **size 和 capacity**：size 表示当前 vector 中有多少个元素；而 capacity 则表示它已经分配的内存中可以容纳多少元素

- **reserve 与 resize**：reserve 是将空间大小（capacity）直接扩充到指定大小；resize() 可以改变有效空间的大小，也有改变默认值的功能，capacity 的大小也会随着改变。

- **vector的元素类型不能是引用**：vector的底层是连续的内存，要求连续的对象排列**，**引用并非对象，没有实际地址
- **vector迭代器失效的情况**：发生内存重新分配，所有迭代器失效；由于使连续内存，因此删除/插入一个元素时，会使后面所有迭代器也会失效，erase方法会返回下一个有效的迭代器，`it=vec.erase(it);`；
- **正确释放 vector 的内存**：
  - `vec.clear()`：清空内容，但是不释放内存。
  - `vector<int>().swap(vec)`：清空内容，且释放内存，想得到一个全新的vector。
  - `vec.shrink_to_fit()`：请求容器降低其 capacity 和 size 匹配。
  - `vec.clear();vec.shrink_to_fit();`：清空内容，且释放内存。
- vector 扩容为什么要以1.5倍或者2倍扩容?
  1.5 倍更好，扩容几次之后，下次扩容的所需内存可以被之前的内存满足，能够重用；而 >= 2倍扩容，每次扩容的大小都超过之前内存之和，无法复用之前的内存。

###### 9.1.2 list

list的底层是一个**双向链表**，以结点为单位存放数据，结点的地址在内存中不一定连续，只能两端顺序访问；每次插入或删除一个元素，就配置或释放一个元素空间，常量时间复杂度。

###### 9.1.3 deque

deque 是一个双向开口的连续线性空间（**双端队列**），支持随机访问；在头尾两端进行元素的插入跟删除操作都有常量时间复杂度。

vector、list、deque 何时选用：vector 可以随机存取元素，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，尽可能选择使用 vector 而非 deque，因为 deque 的迭代器比 vector 迭代器复杂很多。list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。

###### 9.1.4 priority_queue

优先队列，其底层是**用堆来实现**的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。

###### 9.1.5 map 、set、multiset、multimap

- map 、set、multiset、multimap的底层实现都是**红黑树**。

- set 和 multiset会根据特定的排序准则**自动将元素排序**，**set 中元素不允许重复，multiset 可以重复**。

- map 和 multimap **将 key 和 value 组成的 pair 作为元素，根据 key 的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以 map 默认是按 key 排序的）**，map 中元素的 key 不允许重复，multimap 可以重复。

- map 和 set 的增删改查速度为都是 $\log_2n$，是比较高效的。
- map 和 set 的删除仅仅会使当前的 iterator 失效，只要在erase时，递增当前的 iterator 即可。因为**存储的是结点**，使用了红黑树来实现，删除一个结点不会对其他结点造成影响。因此也不需要内存拷贝和内存移动。

###### 9.1.6 unordered_map、unordered_set

unordered_map的底层是一个**防冗余的哈希表**（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找的时间复杂度为 O(1)；而代价是消耗比较多的内存。

<img src="../../../source/images/C++.assets/image-20220724183010867.png" alt="image-20220724183010867" style="zoom:50%;" />

unordered_map 采用 **hash表存储**，map 一般采用**红黑树(RB Tree)** 实现。因此其 memory 数据结构是不一样的。

#### 10. 智能指针

##### 10.1 unique_ptr(非引用计数)

拥有对持有对象的唯一所有权，即两个`unique_ptr`不能同时指向同一个对象，因此是**线程安全**的。这种唯一权体现在：

- unique_ptr 不能被复制到另外一个 unique_ptr，无拷贝构造/赋值运算

- unique_ptr 所持有的对象通过转移语义/主动释放所有权将所有权转移到另外一个 unique_ptr。移动构造/移动赋值
  ```c++
  std::unique_ptr<A> a1(new A());
  std::unique_ptr<A> a2 = a1;//编译报错，不允许复制
  std::unique_ptr<A> a3 = std::move(a1);//可以转移所有权，所有权转义后a1不再拥有任何指针
  std::unique_ptr<A> a4(a1.release());//常见用法，转义拥有权，release 释放所有权并返回原生指针
  ```

##### 10.2 shared_ptr(引用计数)

`shared_ptr` 强调的是共享所有权。也就是说多个`shared_ptr`可以拥有同一个原生指针的所有权，**非线程安全**。shared_ptr 通过引用计数的方式管理指针，当引用计数为 0 时会销毁拥有的原生对象。

对于多线程情况，引用计数虽然是原子变量，但赋值构造函数不是，分为两步：赋值持有指针、增加引用计数。因此在赋值持有指针时，另一线程释放了该指针，就会导致野指针。

##### 10.3 weak_ptr(弱指针)

`weak_ptr` 比较特殊，它主要是为了配合`shared_ptr`而存在的，但 `weak_ptr` 不会增加引用计数。可以用于解决 shared_ptr 的循环引用问题

```c++
{
    shared_ptr<A> a(new A); // new出来的A的引用计数此时为1
    shared_ptr<B> b(new B); // new出来的B的引用计数此时为1
    a->m_b = b; // B的引用计数增加为2
    b->m_a = a; // A的引用计数增加为2
}
```

b 先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放；a 后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放。使用 weak_ptr 后，赋值操作后 A、B 引用计数仍为 1。weak_ptr 可以通过 shared_ptr 创建

```c++
std::shared_ptr<A> a1(new A());
std::weak_ptr<A> weak_a1 = a1;	//不增加引用计数
```

weak_ptr 是一个弱指针，不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个`shared_ptr`，如 weak_a1.lock() 返回一个 shared_ptr。

**线程安全：**weak_ptr 不会增加引用计数，同时 lock() 是原子性的，获得的 shared_ptr 可以安全使用

#### 11. 多线程？



#### 12. 内存模型 [[2]](#[2])

##### 12.1 内存布局

内存布局如下图所示：

<img src="../../../source/images/C++.assets/image-20220728004911457.png" alt="image-20220728004911457" style="zoom:50%;" />

- Code Segment(代码区)：也称Text Segment，存放可执行程序的机器码
- Data Segment(数据区)：存放已初始化的全局和静态变量， 常量数据，如字符串常量
- BSS(Block started by symbol)：存放未初始化的全局和静态变量，默认设为0
- Heap(堆)：从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。
- Stack(栈)：从高地址向低地址增长。由编译器自动管理分配。程序中的局部变量、函数参数值、返回变量等存在此区域

###### 12.1.1 全局变量

当全局/静态变量未初始化的时候，记录在BSS段。处于BSS段的变量的值默认为0，因此 BSS 段内部无需存储大量的零值，而只需记录字节个数即可。系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment)，并将内存初始化为 0，再调用程序入口(main函数)。

而对于已经初始化了的全局/静态变量而言，如声明即初始化，则一直存储于数据段(Data Segment)。

##### 12.2 栈与堆

###### 12.2.1 分配方式不同

- 栈由系统自动分配

- 堆需要程序员自己申请，并指明大小。如 

  - C 中 `p1 = (char *)malloc(10);` 
  - C++ 中 `p2 = (char *)new(10);`

  注意，指针变量还是在栈中

###### 12.2.2 空间大小不同

一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。

###### 12.3.3 分配效率

- 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，**压栈出栈都有专门的指令执行，这就决定了栈的效率比较高**。
- 堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，**堆的效率比栈要低得多**。 

###### 12.4.4 碎片

- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

- 堆：

  - 首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，

  - 另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。        

  - 对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。

  - 对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。 

###### 12.5.5 生长方向

- 栈：生长方向是向下的，向着内存地址减小的方向增长。    

- 堆：生长方向是向上的，向着内存地址增加的方向增长；

##### 12.3 内存对齐

###### 12.3.1 内存对齐的好处

处理器存取内存的单位往往不是字节，例如 32 位系统上，以 4 字节为单位存取内存，因此该处理器只能从地址为 4 的倍数的内存开始读取数据。

假设内存没有对齐，数据以字节大小的地址为单位任意存放，一个 int 变量可能分散到两个 4 字节块中，因此需要读取两个 4 字节块，并移除首尾不需要的字节，再进行合并，非常耗时。如下所示

<img src="../../../source/images/C++.assets/image-20220728002257021.png" alt="image-20220728002257021" style="zoom: 40%;" />

如果内存对齐，一个 int 变量正好只占用一个 4 字节块，因此仅需要一次读取操作。CPU 可以在对齐的内存字上进行的赋值/读取操作是原子操作。

###### 12.3.2 内存对齐规则

基础类型的对齐值为其 sizeof 值，而结构体中**有效对齐值**为结构体中最宽成员和编译器/用户指定对齐值之间的**较小者**：

- 结构体起始地址为有效对齐值的整数倍
- 结构体总大小为有效对齐值的整数倍
- 结构体的第一个成员偏移量为 0，之后成员的偏移量为 min(有效对齐值, 自身大小) 的整数倍

如下结构体所示

<img src="../../../source/images/C++.assets/image-20220726215512997.png" alt="image-20220726215512997" style="zoom: 60%;" />

###### 12.3.3 指定内存对齐值

不同的编译器一般都会有默认的对齐量，一般为 2 的幂次。在 C 中可以通过预编译命令修改对齐量，如

```c
#pragma pack(n)
```

最终的有效对齐量会取结构体最宽成员和编译器/用户指定对齐量中的较小值，C++ 中的对齐操作：

- **alignas**：可以指定对齐量，应用于类/结构体/union/枚举/变量的定义。alignas 指定的对齐量不能小于默认对齐
- **alignof**：返回类型的对齐值，如果是数组，则返回元素类型的对齐值

##### 12.4 new/delete 与 malloc/free

new/delete 底层内存操作默认使用 malloc/free 实现，malloc/free 是 libc 库函数，主要实现了一套内存管理机制，当其管理的内存不够时，通过 brk/mmap 等系统调用向内核申请进程的虚拟地址区间，如果其维护的内存能满足 malloc 调用，则直接返回，free时会将地址块返回空闲链表。因此内存申请有可能触发系统调用，引发系统内核上下文环境切换，开销会较高。

###### 12.4.1 属性上的区别

- new/delete：C++中的关键字，属于操作符，若要使用，需要编译器支持；

- malloc/free：库函数，若要使用则需要引入相应的头文件才可以正常使用。

###### 12.4.2 使用上的区别

- malloc：申请空间需要显式填入申请内存的大小；

- new：无需显式填入申请的内存大小，new 会根据 new 的类型分配内存。

###### 12.4.3 内存位置的区别

- new：此操作符分配的内存空间是在**自由存储区**；

- malloc：申请的内存是在堆空间。

自由存储区可以是堆、全局/静态存储区等，具体是在哪个区，主要还是要看 new 的实现以及 C++ 编译器默认 new 申请的内存是在哪里，绝大多数在堆上。但运算符 new/delete 内部默认是使用 malloc/free 的方式来被实现，因此也可以说是在堆上。

在 C++ 中 new/delete 操作符是可以重载的，我们可以重新实现 new 的实现代码，可以让其分配的内存位置在静态存储区等。而 malloc/free 是 C 里的库函数，无法对其进行重载。

###### 12.4.4 返回类型的区别

- new 操作符内存分配成功时，返回的是对象类型的指针，无须进行类型转换，故 new 是符合类型安全性的操作符
- malloc 内存分配成功则是返回 void * ，需要强制类型转换成所需类型。在 C++ 程序中 new 会比 malloc 安全可靠

###### 12.4.5 分配失败情况的区别

- malloc 分配内存失败时返回 NULL，可以通过判断返回值可以得知是否分配成功

- new 内存分配失败时，会抛出 bac_alloc 异常，不会返回 NULL，如果不捕捉异常，那么程序就会异常退出

###### 12.4.6 动态分配对象内存

使用 new 操作符来分配对象内存时会经历三个步骤：

1. 调用`operator new()`函数(对于数组是operator new\[\]())来分配一块内存空间(底层通常使用 malloc 实现，除非重载 new 符号)以便存储特定类型的对象
2. 运行相应的构造函数以构造对象，并为其传入初值
3. 对象构造完成后，返回一个指向该对象的指针

使用 delete 操作符来释放对象内存时会经历两个步骤：

1. 调用对象的析构函数
2. 编译器调用`operator delete`(或operator delete[])函数释放内存空间(通常底层默认使用 free 实现，除非重载delete 符号)

##### 12.5 new 运算符

new 运算符主要完成两个操作：调用 operator new() 函数，动态分配内存；在分配的内存上调用构造函数，以初始化相应类型的对象，并返回首地址。这里的内存分配默认是 libc 库管理的，如果此时没有可用的堆内存，则会进行系统调用，为进程申请内存。系统调用的开销较大，会造成性能的不稳定。

我们可以重载 operator new 来实现自己的内存分配，标准库中就有几种重载

###### 12.5.1 placement new

placement new 可以指定执行构造类型的内存块，即可以将内存分配与构造分离，形式为`new (ptr) Type(params)`。可用于实现内存池，预申请一块较大的内存，之后的内存分配都在已经申请好的内存池中操作，开销较小。placement new 所调用的 operator new 的重载形式，如
```c++
inline void* __CRTDECL operator new(size_t _Size, void* _Where) noexcept
```

###### 12.5.2 aligned new

另一种 operator new 的重载是可以指定内存对齐值，其使用形式如`new(std::align_val_t{ 32 }) Type(params)`。operator new 的重载形式如

```c++
void* __CRTDECL operator new(size_t _Size, std::align_val_t _Al)
```

#### 13. 语言特性

**编译型语言：**编译到目标机器机器码的格式，通常性能较好，在编译时也能进行较好的优化

**解释型语言：**并不是由目标机器直接执行的，而是由其他程序读取和执行的；不需要经过编译，可以直接运行，对于动态语言来说更方便

运行在虚拟机上的 java 是一种编译型-解释型语言：先编译为平台无关的字节码，执行过程中 java 虚拟机将平台无关字节码逐条解释为目标机器机器码执行

C# 是编译型语言：C#程序在第一次运行的时候，会依赖其.NET Frameworker平台，编译成IL中间码，然后由JIT compiler 翻译成本地的机器码执行。第二次在运行相同的程序时，则不需要再执行以上编译和翻译过程，而是直接运行第一次翻译成的机器码。对于C#来说，通常第一次运行时间会较长。

#### 14 SOA vs. AOS

选数据结构的内存布局用 struct-of-array（SOA）还是 array of struct（AOS）。SOA通常比较适合SIMD，一些运算的吞吐量更高

<img src="../../../source/images/C++.assets/image-20220725104221047.png" alt="image-20220725104221047" style="zoom: 70%;" />

#### 15. 右值与 move [[3]](#[3])

##### 15.1 左值与右值

最简单的区分：左值可以取地址，右值无法取地址。例如 `int a = 5`，a 是左值，5 是右值

##### 15.2 左值引用与右值引用

引用本质是变量的别名，形参使用引用可以避免对象拷贝，这一点对于左值/右值引用都是成立的。二者区别在于：

- 左值引用：指向左值，可以通过引用来修改指向的左值。而右值无法取地址，因此无法修改，但可以使用 **const 左值引用指向右值**。如下，
  ```c++
  int a = 5;	// a 是左值
  int& left_ref_a = a;	// 左值引用 left_ref_a 指向左值 a，对二者取地址得到的结果相同
  int& left_ref_5 = 5;	// 左值引用指向右值 5，不合法，编译错误
  const int& const_left_ref_5 = 5;	// const 左值引用无法修改，指向右值合法
  ```

- 右值引用：指向右值，但不能指向左值
  ```c++
  int&& right_ref_5 = 5;	// 右值引用指向右值 5
  right_ref_5 = 6;		// 右值引用可以被修改
  int&& right_ref_a = a;	// 右值引用指向左值 a，不合法，编译错误
  int&& right_ref_a = std::move(a);	// 可以将左值 a 转为右值
  ```

因此 **const 左值引用可以接受左值、右值，但右值引用只能接受右值**。在向函数传递右值引用类型参数时，首先匹配该函数的右值引用类型形参版本，如果找不到，则再匹配 const 左值引用类型版本。

对于引用本身而言，也有左右值之分。对于左值引用无论是否为 const 其本身都是左值；对于右值引用只要有名称都是左值，但匿名右值引用(例如返回值)属于右值。可以使用取地址操作，来进行验证。

```c++
const int* p_const_left = &const_left_ref_5;	// 指向右值的 const 引用取地址合法，左值引用本身为左值
int* p_ret_left = &(t.GetLeftRefVal());	// 左值引用的返回值，直接取地址合法，左值引用作为返回值本身也是左值
int* p_right_ref = &(right_ref_a);		// 带名称的右值引用可以取地址，其本身为左值
int* p_ret_right = &(t.GetRightRefVal());	// 右值引用的返回值取地址不合法，编译错误，其本身为右值
```

##### 15.3 std::move

`std::move` 移动不了什么，**只是类型转换工具，把左值强制转化为右值**，等同于 `static_cast<T&&>(lvalue)`。使用 move 将左值转为右值后，可以触发移动语义，即调用右值引用版本的函数，告诉被调用函数该对象之后不再需要，被调用函数可以直接转移对象所有权，不必进行深拷贝。例如

```c++
class A {
public:
	A(A&& other) {	// 移动构造函数
        this->b = other.b;	// 浅拷贝
        other.b = nullptr;	// 防止后续被使用
	}
private:
    B* b;
};
```

STL 的大多数函数都有移动语义版本，例如 emplace_back，std::string 也有移动语义版本的构造函数。

##### 15.4 完美转发 std::forward

std::forward<T>(u)：当 T 为左值引用类型时，u 将被转换为 T 类型的左值；否则 u 将被转换为 T 类型右值。

#### 16. SFINAE [[4]](#[4])

#### 17. 大小端

**大端模式，**是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；

**小端模式，**是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

**测试方法**：使用 short int (占两字节) 变量

```c++
short int x;
char x0,x1;
x=0x1122;
x0=((char *)&x)[0];  //低地址单元
x1=((char *)&x)[1];  //高地址单元
```

#### 18. 宏相关 [[6]](#[6])



#### 1. emplace_back vs push_back

- 相同点
  二者都是在尾部加一个元素，

- 不同点
  - 参数上
    emplace_back 支持可变参数，可以直接传对象的构造函数的参数列表添加一个新元素，
    如 `vec.emplace_back(arg1, arg2)`
    push_back 不支持可变参数，当对象的构造函数只有一个参数时，可以使用隐式类型转换添加一个新元素。如果对象的构造函数多余一个参数，只能使用初始化参数列表传递参数，
    一个参数的构造函数情况： `vec.push_back(arg)` 
    两个参数的构造函数情况：`vec.push_back({arg1, arg2})`。错误用法`vec.push_back(arg1, arg2)`
  - 内存上 emplace_back 性能要优于 push_back
    当使用上述参数列表添加一个元素时，push_back 比 emplace_back 多一次拷贝/移动构造操作
    push_back 会先创建一个临时对象，再使用移动构造函数放到 vector 尾部元素的内存区域。
    emplace_back 使用的是就地构造，即直接在 vector 尾部元素的内存区域构造。







#### Reference

<a name="[1]">[1]</a> https://zhuanlan.zhihu.com/p/41309205

<a name="[2]">[2]</a> https://zhuanlan.zhihu.com/p/344377490

<a name="[3]">[3]</a> https://zhuanlan.zhihu.com/p/335994370

<a name="[4]"> [4]</a> https://zhuanlan.zhihu.com/p/21314708

<a name="[5]">[5]</a> https://zhuanlan.zhihu.com/p/151995167

<a name="[6]">[6]</a> https://cloud.tencent.com/developer/article/1919679