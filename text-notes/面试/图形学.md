#### 1. 前置概念

##### 1.1 Depth Complexity vs. Overdraw

- Depth Complexity (深度复杂度)：表示一个像素被多少个面片包含。可以通过特殊配置的绘制方式可视化：关闭 深度测试，并使用 `glBlendFunc(GL ONE,GL ONE)`，像素着色器只输出 $(1/255,1/255,1/255)$。绘制完所有 mesh 的最终结果解释场景的深度复杂度，越白的像素表示其复杂度越高。
- Overdraw：表示在实际渲染中，一个像素的 pixel shader 被执行了多少次。例如场景中有两个物体，A、B，A 整体在 B 前。如果先画 A 后画 B，每个像素最多只会计算一次，因为 B 被 A 遮挡的部分，由于深度缓冲被丢弃掉，不会执行 pixel shader。但如果先画 B 后画 A，两者重叠部分的像素计算不止一次。消除 overdraw 的常见做法是，增加一个 z-prepass，只生成场景的 depth buffer。在后续的实际渲染中直接使用该 depth buffer，来避免像素的 overdraw。
- early-z 开启后将深度测试提前到 pixel shader 之前，光栅化过程中。z-prepass 是指先使用一个 depth only pass 得到场景的 depth buffer，然后使用 depth buffer 再执行第二个 pass。

#### 2. 抗锯齿

##### 2.1 几何锯齿 vs. 着色锯齿 [[1]](#[1])

- 几何锯齿：主要由于光栅化时的采样不足导致，体现在几何边缘的锯齿现象
- 着色锯齿：主要由于渲染（例如光照计算）的采样不足导致，体现在画面中的部分像素点的闪烁或者噪点

<img src="图形学.assets/v2-8b270916dcd69499862fc7cd7a5fc181_720w.jpg" alt="img" style="zoom: 67%;" />

##### 2.2 超采样

超采样类抗锯齿只对几何锯齿有效。

- MSAA：为了减轻几何边缘由于采样不足带来的锯齿，NxMSAA 会为每个像素划分为 N 子采样点。在 MSAA 下，深度测试会为每个子采样点进行，因此 depth buffer 增大到 N 倍。对于着色而言，MSAA 下的像素虽然会有多个子采样点，但每个像素的着色最多只会执行一次。

  - 如果表面覆盖到像素中心，那么在像素中心位置计算着色，通过深度测试的子采样点则共享这一着色结果。
  - 如果表面没有覆盖到着色中心，则选择距离最近的子采样点计算着色。

  这样下来得到 NxMSAA 的 render target，还需要额外的 resolve 操作，得到最终的 render target。resolve 操作使用一个 box filter 将像素的所有子采样点的着色进行平均。此外，像素的子采样点的位置硬件层通常采用一个低差异序列。

##### 2.3 TAA

时序抗锯齿是找到当前帧像素在上一帧中对应的历史帧像素，将历史帧像素与当前帧像素结合起来作为最终着色，从而提高采样率。同时当前帧像素需要做一定的抖动，不然当前帧与历史帧对应像素完全一样，无法提高采样率。TAA 有以下步骤：

- 抖动操作：绘制当前帧像素时，通过修改变换矩阵，将原像素位置在像素范围内进行抖动，抖动的大小可以使用 halton 低差异序列。

- 重投影：计算当前帧像素当上一帧像素的运动矢量，即当前帧像素位置与历史帧像素位置的差值。MVP 变换已知，动画等变换也已知，则可以计算出每个像素的运动矢量 $v_{motion}$，像素 $p$ 对应的历史帧像素为 $\pi_{t-1}(p)=p-v_{motion}$

- 加权混合当前帧与历史帧：指数平滑混合，$\alpha$ 为混合权重通常取 $0.1$
  $$
  f_t(p)=\alpha \cdot s_t(p) + (1-\alpha)f_{t-1}\left(\pi_{t-1}(p)\right)
  $$

有一些情况会造成历史帧像素失效，不可用：

- 场景切换、光源切换、相机切换
- 去遮挡

#### 3. Shading 方式 [RTR4-chapter 20]

##### 3.1 Deferred Shading

在 forward shading 中，单个 pass 使用一个 mesh 和 shader渲染最终图像，在这个 pass 中需要执行渲染所需的所有操作，如从贴图或 buffer 中提取材质参数，对一系列光源进行光照计算等。而 deferred shading 则将光照计算部分解耦出来，先使用一个 geometry pass 将所有可见像素的材质属性、几何属性渲染到 G-Buffer 中，再使用一个 postprocess pass 对 G-Buffer 中存储的材质、几何数据应用光源。 使用 z-prepass 的 forward pass 也可以看作几何数据渲染与着色的轻度解耦。Deferred Shading 有如下方面的优缺点：

- shader 代码复杂性降低：forward shading 把几何数据和着色放在了一个 shader 中计算，其代码长且复杂，以及较多的 dynamic-branch。这样的 shader 需要的寄存器数量会很多，同时在 dynamic-branch 的作用下，会导致 GPU 占用率降低(同时执行的 shader invocation)。deferred shading 的解耦使得每个 pass 的 shader 代码更为简洁。
- G-Buffer：包含的数据依赖于用户的实现，一般包含材质属性（PBR中的贴图），法线贴图、位置信息（一般只存储深度，使用深度和贴图坐标即可恢复三维坐标）
- 多个光源的情况：对每个光源逐个执行一次 postprocess pass，但如果每次都是 full-screen quad shading，相当于每个像素都会进行 G-Buffer 数据提取、光照计算等，这种做法效率甚至低于 forward shading(由于额外的 G-Buffer)。对于多光源常见做法是使用 light volume，即每个光源影响的三维区域。将 light volume 投影到屏幕空间得到一个较小的 quad 来覆盖 light volume。light pass 只对 quad 范围内的像素计算，同时 light volume 投影的像素会有一个最小和最大深度区间，如果着色像素的深度不在这个区间内，则表示该像素不受光源影响，也可以跳过该像素的光照计算。
- MSAA 难以在 deferred shading 中应用：NxMSAA 需要 N 倍大小的 render target，因此 G-Buffer 的存储开销增大到 N 倍。
- 透明材质：透明材质的渲染与次序相关，靠前的透明物体与其后的不透明物体会发生融合。在 basic deferred shading 中无法处理透明材质，可以结合 deferred shading 与 forward shading，deferred shading 渲染不透明物体，再使用一次 forward shading 处理透明材质。

##### 3.2 Tiled Shading

Tiled shading 的核心思想是：将 render target 划分为以 tile 为单位的像素块，为每个 tile 记录其收到影响的光源列表，在单个 shader invocation 中执行所有光源的光照计算，而不是 basic deferred shading 中对每个光源执行一次 shader。每个 tile 的光源列表需要通过 light volume 与 tile 对应的 frustum 求交来确定：

- tile 的 frustum：tile 的最小/最大深度构成 frustum 的远近平面，并且与相机 frustum 的远近平面平行。
  <img src="图形学.assets/image-20220621112549093.png" alt="image-20220621112549093" style="zoom:50%;" />
- light volume：可以使用一个球包含光源影响区域，使用这个球与 tile frustum 求交
- 求交：

Tiled Shading 可以与 deferred shading 或 forward shading 结合。

###### 3.2.1 Tiled deferred shading

在G-Buffer 构建方面 tiled/basic deferred shading 二者并无差别。但在 basic deferred shading 中，光源是逐个计算，并且每次计算只绘制光源覆盖的四边形区域。而 tiled deferred shading 中，每个 tile 记录与其相交的光源列表，在一次 full-screen quad shading 中计算所有光源，这种方式有以下好处：

- 每个像素最多只会访问一次 G-Buffer，而不是有多少个与其重叠的光源就访问多少次。
- render target 的每个像素也只会写一次，而不是累计每个光源的结果
- shader 代码可以更高效处理渲染方程中的公共项，而不需要为每个光源单独计算
- 在不透明物体渲染完成后，可以在 forward shading 中使用同样的光源列表渲染透明物体
- tile 中的每个像素计算同一个光源列表，这对于 GPU 执行更高效

###### 3.2.2 Tiled forward shading(forward+)

先使用一个 early-z pass 得到场景深度，然后使用 compute shader 来得到 tile 的光源列表。

###### 3.2.3 深度不连续

Tile 中不连续深度会降低 Tiled Shading 的性能，如近处的角色与远处的山之间的不连续深度占比很高。这会导致一个 tile 的光源列表很大，但实际要计算的很少，即 tiled shading 不能有效剔除多数无影响光源。一些降低不连续深度影响的解决方案有：

- HalfZ：除了 tile 的最大/最小深度之外，增加一个中间深度值，将 tile frustum 为远近两个部分。相交的光源有三种情况，覆盖近处、覆盖远处、全覆盖。根据 tile 中像素深度来应用不同分类的光源列表。
- 2.5D culling：将 tile 深度分为 32 个区间，每个光源使用一个 32 位标志，每位来表示光源是否覆盖了对应区间。像素的深度得到的 32 位标志与光源标志位进行与运算，不为零，则表示受到该光源的影响。

##### 3.3 Cluster Shading

Tiled shading 是屏幕空间的二维划分，而 cluster shading 则是对相机的整个 view frustum 的三维划分。

#### 4. 变换

##### 4.1 坐标系

如下所示的 OpenGL 的左手坐标系与 Vulkan 右手坐标系

![image-20220705185853612](图形学.assets/image-20220705185853612.png)

- 左手坐标系使用左手法则判断叉乘方向：四指指向叉乘第一个向量，绕向第二个向量，大拇指指向即为叉乘结果向量的方向。
- 右手坐标系使用右手法则判断叉乘方向，过程与左手相同

$\vec{X}\cross \vec{Y}$ 的方向服从左手法则即为左手坐标系，反之为右手坐标系。注意这里只是判定方向朝向，叉乘计算公式在左手或右手坐标系都是一样的。


##### 4.2 MVP

投影变换 [[2]](#[2])

##### 4.3 法线的变换

法线经常用于光照的计算，计算可以发生在 view space 或 world space。假设在 view space 中进行光照计算，local space 到 view space 的变换为 MV。但对于处于 local space 的顶点法线，有时不能直接应用 MV 变换。例如当模型变换具有 non-uniform scale，则变换后的法线不再垂直原表面。如模型变换的 scale 为 (2, 1, 1, 1)，有如下变换示例

<img src="图形学.assets/image-20220630201945592.png" alt="image-20220630201945592" style="zoom:48%;" /><img src="图形学.assets/image-20220630202012731.png" alt="image-20220630202012731" style="zoom: 50%;" />

把法线从 local space 变换到 world space 的正确变换为 $((MV)^{-1})^T$，也就是说 MV 变换的逆的转置。

#### 5. 渲染管线

<img src="图形学.assets/image-20220630205551591.png" alt="image-20220630205551591" style="zoom: 30%;" />

<img src="图形学.assets/image-20220630211914450.png" alt="image-20220630211914450" style="zoom: 60%;" />

##### 5.1 Application

Application 阶段绝大多数部分运行在 CPU，也有可能有 Compute Shader。该阶段通常处理交互逻辑，场景中的剔除、碰撞检测、处理外设输入等。在 Application 阶段结束会将几何数据、以及相关参数送入 Geometry Processing 阶段。

##### 5.2 Geometry Processing

执行在 GPU，用以处理 per-triangle 和 per-vertex 的操作。可以被分为 Vertex Shading、Projection、Clipping、Screen Mapping 四个子阶段：

- Vertex Shader：输入为 vertex buffer 中的 vertex，经过**顶点着色器**的计算，例如 MVP 变换，最终顶点位于 [-1,1]x[-1,1\]x[-1,1] 的立方体（**view volume**）内，即位于 clip space。顶点会包含多个属性，如位置、法线、颜色等，经过 vertex shader 的计算，会输出后续阶段需要的数值，这些输出会在（除了显示声明 `flat` 外）三角形内部进行插值。view volume 的 z 坐标范围不同 API 是不同的，Opengl 为 [-1,1]，direct3D 与 vulkan 为 [0,1]。
- 可选阶段 Tessellation：
- 可选阶段 Geometry Shader：处理几何图元，如点、线、三角形。几何着色器用于修改输入数据
- Clipping：经过 MVP 变换，模型处于 clip space，只有在 view volume 内部的图元部分才会被送入之后的 Rasterization 阶段。对于完全位于 view volume 之内或之外的图元会被送入或不送入下一阶段。而对于部分位于 view volume 的图元需要进行 clipping，如下所示
  <img src="图形学.assets/image-20220701104411555.png" alt="image-20220701104411555" style="zoom: 40%;" />
- Screen Mapping：view volume 内的图元会送入 screen mapping 阶段。此阶段位于 clip space 的坐标会被映射到屏幕坐标以及映射 z 坐标。绘制窗口由屏幕坐标 (x1, y1) 和 (x2, y2) 定义，唯一 [-1,1]x[-1,1] 的 (x,y) 坐标映射到屏幕坐标范围内。（Opengl 为 [-1,1]，direct3D 与 vulkan 为 [0,1]）z 坐标也会映射范围为 [z1, z2]。默认 z1=0，z2=1。
  <img src="图形学.assets/image-20220701114119545.png" alt="image-20220701114119545" style="zoom: 40%;" /> 

##### 5.3 Rasterization

对于几何图元为三角形的管线，geometry process 阶段的数据流为 vertex stream。在此阶段首先将 vertex 组装成三角形，数据流变为了 triangle stream。如果开启了背面剔除，则之后的操作只会对正面三角形进行。接下来查找位于三角形内部的像素，三角形顶点的属性会在像素位置进行插值。

如果开启了 `early-z`，例如 glsl 中的 fragment shader 中显示声明 `layout(early_fragment_tests) in;`，merging 阶段的模板测试与深度测试就会提前到 Rasterization 阶段。如果开启了模板测试，则丢弃无法通过模板测试的像素。之后再丢弃无法通过深度测试的像素。early-z 会将处于后面的像素完全丢弃，不会进入 pixel shader 及之后阶段(blend 阶段)，无法应用在半透明物体。

##### 5.4 Pixel Processing

Pixel Processing 阶段执行 per-pixel 或 per-sample 计算。

###### 5.4.1 Pixel Shader

像素着色器会使用顶点着色器的输出在该像素位置的插值结果、以及一些管线输入参数，计算出该像素的输出值。

###### 5.4.2 Merging

对像素着色的输出值以及对应的深度值执行 merge 操作，写入 frame buffer 中。有如下操作顺序，

1. **alpha test**：如果通过 API 开启了 alpha test，则先将不通过 alpha test 的像素直接丢弃，例如 alpha 通道小于某个值。alpha test 也可以直接在 pixel shader 中使用 `discard` 实现。alpha test 与 early-z 同时开启会导致 early-z 失效，例如一个近物体被 early-z 写入深度缓冲，后续的 alpha test 将其丢弃，但其深度值已经在深度缓冲，该物体之后的物体就无法通过深度测试。
2. **模板测试**：如果开启了模板测试，则将不通过模板测试的像素丢弃。
3. **深度测试**：默认的深度测试（即无 early-z）在此时发生，只将通过深度测试的像素的深度值更新入深度缓冲区。
4. **blend**：最后，像素着色器的输出与 frame buffer 的 color 执行 blend 操作，如果是不透明物体，则是直接覆盖或丢弃。透明度使用 alpha 通道描述，管线提供可配置的 blend 操作，以及最终的 alpha 值如何更新。

#### 6. 光线与三角形求交 [[3]](#[3])

##### 6.1 重心坐标

使用三角形三个顶点的线性组合可以表示三角形内的任一点，线性组合的权重即为重心坐标。如下三角形，
<img src="图形学.assets/image-20220705201941185.png" alt="image-20220705201941185" style="zoom: 25%;" />
三角形内部一点 $S$ 使用重心坐标 $(\alpha,\beta,\gamma)$ 有 $S=\alpha A+\beta B+\gamma C$，其中 $\alpha+\beta+\gamma=1$。
三角形内一点可以按上图方式，将三角形划分为三部分，面积分别为 $A_A,A_B,A_C$。顶点 $A$ 的权重为其对着的 $SBC$ 面积占总面积的比例，有
$$
\begin{cases} \alpha=\frac{A_A}{A_A+A_B+A_C} \\ \beta=\frac{A_B}{A_A+A_B+A_C} \\ \gamma=\frac{A_C}{A_A+A_B+A_C} \end{cases} \quad \quad \quad \begin{cases}A_A=\frac{1}{2}||\mathbf{SC}\times \mathbf{SB}|| \\ A_B=\frac{1}{2}||\mathbf{SC}\times \mathbf{SA}|| \\ A_C=\frac{1}{2}||\mathbf{SA}\times \mathbf{SB}||\end{cases}
$$
叉乘向量的长度的一半即为三角形面积：$A_A=\frac{1}{2}||\mathbf{SC}\cross\mathbf{SB}||$。推导：叉乘公式: $\mathbf{SC}\times\mathbf{SB}=||\mathbf{SC}||\cdot ||\mathbf{SB}||\sin\theta \cdot \mathbf{n}$，$\mathbf{n}$ 为右手定则指定的方向。$||\mathbf{SB}||\sin\theta$ 为边 $\mathbf{SC}$ 上的高，三角形面积为$\frac{1}{2}||\mathbf{SC}\times\mathbf{SB}||=\frac{1}{2}||\mathbf{SC}||\cdot ||\mathbf{SB}||\sin\theta$

**重心坐标性质**：仿射不变性，即仿射变换前后重心坐标不变。仿射变换是一个线性变换(旋绕、缩放、切变等)加上一个平移变换，变换前后的坐标维度不变。透视投影属于非线性变换，重心坐标会发生改变。因此，三维空间得到的重心坐标不能用于透视投影的 clip 空间，反之亦然。

##### 6.2 光线与三角形求交点

**光线定义**：$r(t)=O+t\textbf{d} \quad 0\leq t\leq \infty$ , 该式定义的是光线上的任一点。

###### 6.2.1 Moller Trumbove Algorithm（联立方程组求解）

光线与三角形相交，即求解方程组 $O+t\textbf{d}=(1-b_1-b_2)P_0+b_1P_1+b_2P_2$。 

点、向量都为三维，未知变量有三个，可以使用线性代数中的克拉姆法则求解。如果 $t, b_1,b_2,1-b_1-b_2$ 都非负，则证明交点在三角形内，即光线与三角形有交点。

###### 6.2.2 Watertight Ray-Triangle Intersection（降维计算）

构建一个以光线起点为原点，以光线方向为 $z$ 轴正方向的坐标系。将三角形变换到该坐标系，在该坐标系中进行求交。由于光线为 $z$ 轴，因此，若有交点，则交点 $x,y$ 坐标必为 $0$。反之，如果三角形内部有一点 $x,y$ 坐标为 $0$ ，且该点在光线范围内$(t>0)$，那么此点必为交点。求交问题则转换为了点 $(0,0)$ 是否在三角形内部，三维降为了二维。

**判断点是否在三角形内的传统做法（三维）**：如下三角形中，如果 $P_0P_1\times P_0P$、$P_1P_2\times P_1P$、$P_2P_0\times P_2P$ 三个向量的方向相同，则 $P$ 位于三角形内部。<img src="图形学.assets/image-20220705210153465.png" alt="image-20220705210153465" style="zoom: 50%;" />
 **利用叉乘性质得到的 signed edge function（二维）**：使用叉乘的行列式公式展开可知 $(\mathbf{a}_x\mathbf{b}_y-\mathbf{a}_y\mathbf{b}_x)$ 决定叉乘方向 $z$ 坐标的符号。因此可以得到上述三个叉乘的 signed edge function，得到 $e_0,e_1,e_2$。如果同号则表示 $(0,0)$ 在三角形内部。交点的重心坐标为 $\large b_i=\frac{e_i}{e_0+e_1+e_2}$，代入计算交点 $z$ 坐标，从而得到 $t$ 值。

#### 7. 光线与 Bounding Box 求交



#### 8. 画直线算法（DDA 与 Bresenham）

已知线段的两个端点 $P_0(x_0, y_0)$ 与 $P_1(x_1,y_1)$，实现绘制该直线。已知两个端点，该直线方程可以描述为 $y=kx+b$ 。DDA 与 Bresenham 都是步进方式，即一个坐标步进 1 个像素，另一个坐标根据直线方程步进对应像素，得到了直线上下一个点的坐标。一直重复该步骤直到终点。

##### 8.1 DDA 算法

要保证查找的下一个像素点是连续的，即坐标的最大步长不能超过 1 个像素，因此沿哪个轴作为步进方向取决于斜率。有两个端点可以求得 $\Delta x=x_1-x_0,\Delta y=y_1-y_0,k=\frac{\Delta y}{\Delta x}$。以 $k>0$ 为例，下一个坐标的确定方式为：

- 如果 $|\Delta x| > |\Delta y|$，即 $|k|<1$。那么选取 $x$ 为步进方向，下一个坐标为，$y=y+k,x=x+1$
- 如果 $|\Delta x| < |\Delta y|$，即 $|k|>1$。那么选取 $y$ 为步进方向，下一个坐标为，$y=y+1,x=1/k$

对于任意 $k$，需要预先计算 $x,y$ 的步进带符号步长。总步数 $step=\max\{abs(\Delta x), abs(\Delta y)\}$。那么 $x,y$ 的步长分别为
$$
\begin{cases}
xInc = \frac{step}{\Delta x} \\
yInc = \frac{step}{\Delta y}
\end{cases}
$$
每次步进 $(x,y)=(x+xInc,y+yInc)$，直至完成总步数。每次步进后的坐标都需要进行依次舍入到像素位置。

##### 8.2 Bresenham 算法

Bresenham 算法是对 DDA 算法的改进，去除了 DDA 算法中的浮点运算，全部使用整数运算，提高了性能。

首先直线方程改为隐式：$f(x,y)=y-kx-b=0$。
**下面以 $0<k<1$ 为例描述算法过程**，如下图所示，$P_i(x_i,y_i)$ 为当前像素，则下一个像素的两个候选为 $P_u(x_i+1,y_i+1),P_d(x_i+1,y_i)$，两个候选像素的中点为 $M(x_i+1,y_i+0.5)$。

<img src="图形学.assets/image-20220706113341883.png" alt="image-20220706113341883" style="zoom: 35%;" />

将候选像素中点 $M$ 代入直线方程：$d_i=f(x_i+1,y_i+0.5)=y_i+0.5-k(x_i+1)-b$。如果 $d_i<0$，则表示候选像素中点位于直线下方（黑色实线），下一个像素选择 $P_u$；如果 $d_i>0$，则表示候选像素中点位于直线上方（绿色虚线），下一个像素选择 $P_d$。下面需要计算出 $d_{i+1}$ 的递推公式：

- 如果 $d_i<0$，$P_{i+1}(x_i+1,y_i+1)$，此时的两个候选像素为 $P_u(x_i+2,y_i+2),P_d(x_i+2,y_i+1)$，中点为 $M(x_i+2, y_i+1.5)$。因此 $d_{i+1}=f(x_i+2,y_i+1.5)=y_i+1.5-k(x_i+2)-b=d_i+1-k$
- 如果 $d_i>0$，$P_{i+1}(x_i+1,y_i)$，此时的两个候选像素为 $P_u(x_i+2,y_i+1),P_d(x_i+2,y_i)$，中点为 $M(x_i+2, y_i+0.5)$。因此 $d_{i+1}=f(x_i+2,y_i+0.5)=y_i+0.5-k(x_i+2)-b=d_i-k$

递推公式：$d_0=0.5-k$，若 $d_i<0$，$d_{i+1}=d_i+1-k$，否则 $d_{i+1}=d_i-k$ 。由于我们只需要知道 $d$ 的正负，因此可以使用 $2\Delta x \cdot d$ 作为新的 $d$，这样就去除了浮点运算，有 
$$
d_0=\Delta x-2\Delta y, \quad \quad d_{i+1}=\begin{cases} 
d_i+2\Delta x-2\Delta y, \quad d_i<0 \\
d_i-2\Delta y, \quad\quad\quad\quad otherwise
\end{cases}
$$
**扩展到所有范围的 $k$**

- 如果 $-1<k<0$，当前像素 $P_i(x_i,y_i)$，候选像素为 $P_u(x_i+1,y_i),P_d(x_i+1,y_i-1)$，候选像素中点为 $M(x_i+1,y_i-0.5)$，$d_i=f(x_i+1,y_i-0.5)=y_i-0.5-k(x_i+1)-b$，其中 $i=0$ 为起点，位于直线上有 $d_0=-0.5-k$

  - $d_i>0$ 时，选择 $P_u$，$d_{i+1}=f(x_i+2,y_i-0.5)=d_i-k$；
  - 否则选择 $P_d$ ，$d_{i+1}=f(x_i+2,y_i-1,5)=d_i-1-k$

  以使用 $2\Delta x \cdot d$ 作为新的 $d$ 去除浮点运算，有
  $$
  d_0=-\Delta x-2\Delta y, \quad \quad d_{i+1}=\begin{cases} 
  d_i-2\Delta x-2\Delta y, \quad d_i<0 \\
  d_i-2\Delta y, \quad\quad\quad\quad otherwise
  \end{cases}
  $$

- 如果 $|k|>1$，则步进主方向改为 $y$，推导方式与 $|k|<1$ 相似

##### 8.3 画圆算法

画圆同样是寻找像素点，直线方程换为圆方程。如果以圆心为原点建立坐标系，可以利用圆的八对称性，即找到一个像素点即可找到其对应的其他 7 个点，如下图所示

<img src="图形学.assets/image-20220706194614096.png" alt="image-20220706194614096" style="zoom:50%;" />

#### 9. 模板缓冲与模板测试

模板缓冲区可以为屏幕上每个像素保存一个无符号整数（一般为8bit整数，这和alpha 通道的8bit整数相同），在渲染流程中，使用每个像素的模板数值与一个预先设定好的模板参考值相比较（一般是按位与操作），根据这个比较的结果来决定是否更新相应像素的颜色值，这个比较的过程叫做**模板测试**。功能如下所示
<img src="图形学.assets/image-20220706202823882.png" alt="image-20220706202823882" style="zoom:50%;" />

模板缓冲区与深度缓冲区的大小相同。在使用的过程中，一般先开启模板缓冲，绘制一个物体作为我们的模板，这个过程实际上就是写入模板缓冲的过程；接着我们利用模板缓冲中的值决定是丢弃还是保留后续绘图中的片元。大致过程如下：

1. 开启模板缓冲写入，指定之后的渲染写入模板缓冲区的值。
2. 渲染物体，更新模板缓冲。物体的渲染区域在模板缓冲区的对应区域会写入步骤 1 指定的值
3. 关闭模板缓冲写入。之后的渲染不会修改模板缓冲区的数值。
4. 指定模板测试操作：指定运算操作、操作数以及比较方式。
5. 渲染（其他）物体，使用物体的渲染区域在模板缓冲区中对应的数值，基于步骤 4 指定的模板测试操作决定是否丢弃像素片段。

**非 early-z 下，模板测试发生在透明度测试之后，深度测试之前**，如果模板测试通过，则相应的像素点更新，否则不更新。

#### 10. 半透明渲染

保证融合公式的正确，OIT

#### 11. 纹理映射与过滤

Vertex Shader 可以输出每顶点的纹理坐标，三角形内部每个像素的纹理坐标使用重心坐标插值而来。Pixel Shader 使用每像素纹理坐标对贴图进行采样，即获取指定坐标位置的数据**（纹素）**。纹理坐标是标准化浮点数，乘上贴图的分辨率得到 UV 坐标。纹素与像素通常无法一一对应，无法得到整数 UV：

- 如果相机离物体较近，则三角形占据的屏幕像素分辨率要高于纹理分辨率，即纹理分辨率不足
- 如果相机离物体较远，则一个纹素可能覆盖到多个像素，即纹理分辨率过大

##### 11.1 Texture Magnification

当低分辨率纹理映射到高分辨率物体时，纹理分辨率不足。使用浮点坐标对周围纹素进行插值，得到最终的采样坐标。如下图的红色浮点坐标，黑色整数坐标，

<img src="图形学.assets/image-20220708191612938.png" alt="image-20220708191612938" style="zoom: 33%;" />

**双线性插值（Bilinear Interpolation）**：

#### References

<a name="[[1]]">[1]</a> https://zhuanlan.zhihu.com/p/142922246

<a name="[2]">[2]</a> [Projection Transformations](../graphic basics/1. Projection Transformations.md)

<a name="[3]">[3]</a> [Ray-Triangle and Ray-bounding box Intersection](../pbrt/3.1 Ray-Triangle and Ray-bounding box Intersection.md)
